#summary Developer How-To: Add a new diagnostic variable in the property list

<wiki:toc max_level="1" />

=Motivation=
Often, the user needs to compute a new diagnostic quantity, one that is not available on the current [UsersManual#Property_list _property list_]. Hence, this tutorial serves to guide the user to become a developer, and to help him create new diagnostic quantities in the SHEL. The developer is also encouraged to submit new quantities to this googlecode project.

*In this tutorial, a dummy property, called `dummy1`, will be created.*

=Which grid type?=
*Determine which is the best suited [DevelopersManual#The_Arakawa_C_staggered_grids_matricial_design grid type]*. 

All properties are, eventually, interpolated on a [DevelopersManual#The_Arakawa_C_staggered_grids_matricial_design T-cell], for graphical rendering purposes. However this does not mean they are all computed on T-cells. This is the first important design step. Is this quantity naturally computed on T, U, V or W-cell grid? 

For example, the `curl` is a quantity naturally computed on the W-cell (see the [TechnicalGuide technical guide] for more details on the which grid cells are computed the properties). Thus, the global variable `curl_w` was [http://code.google.com/p/shel/source/browse/trunk/ComputeDiagnostics.m#233 computed on a W-cell and was later interpolated on a T-cell], to the global variable `curl_t`. 

*In this case, `dummy1` is computed on a W-cell.*

=Create the diagnostic variable=

Edit the following files.

==initialconditions.m==

Create the global variable `dummy1_t`, at [http://code.google.com/p/shel/source/browse/trunk/initialconditions.m#196 the end of the diagnostic quantities in the T-cells code zone],
{{{
global sqdivergence_t; '%the square of the horizontal divergence.'
global okuboweiss_t; '% the okubo-weiss scalar (sqstrain - enstrophy) '
                    '%(Check Arakawa1966 and Weiss1981)'
global dummy1_t; '% always comment what this quantity is!'
}}}

and create the global variable `dummy1_w`. [http://code.google.com/p/shel/source/browse/trunk/initialconditions.m#232 at the end of the W-cells (or Z-cells )code zone],
{{{
global okuboweiss_w; '% the okubo-weiss scalar (sqstrain - enstrophy)' 
                    '%(Check Arakawa1966 and Weiss1981)'
global dummy1_w; '% always comment what this quantity is!'
}}}

Allocate memory for the new global variable `dummy1_t`, [http://code.google.com/p/shel/source/browse/trunk/initialconditions.m#442 at the end of the T-cells allocation]:
{{{
sqdivergence_t = zeros(M,N);
dummy1_t = zeros(M,N);
}}}

and allocate memory for the new global variable `dummy1_w`, [http://code.google.com/p/shel/source/browse/trunk/initialconditions.m#416 at the end of the W-cells allocation (Z-cells)]:
{{{
okuboweiss_w = zeros(M+1,N+1);
dummy1_w = zeros(M+1,N+1);
}}}

==computeDiagnostics.m== 

Create the function that computes the `dummy1_w` global variable, at the end, [http://code.google.com/p/shel/source/browse/trunk/ComputeDiagnostics.m#383 right before the `interpolFtoT` function].

{{{
'%%%% New code begins here %%%%'
function computeDummy1_w
  global u;
  global v;
  global dummy1_w; '%W-cell global variable'
  global dummy1_t; '%T-cell global variable'
  global mask; '%T-cell land mask'

  '%Algorithm of dummy1'
  dummy1_w(2:M,2:N) = u(1:M-1,2:N) + u(2:M,2:N) + v(2:M,1:N-1) + v(2:M,2:N);

  '%Interpolation of dummy1 to a T-cell'
  dummy1_t = interpolFtoT(dummy_w, mask, M, N)
'%%%% New code ends here %%%%'

function tgrid = interpolFtoT(fgrid, mask, M, N)
'%% function tgrid = interpolFtoT(fgrid, mask, M, N)'
tgrid = .25 * mask .* ( ...
              fgrid(1:M,1:N) ...
            + fgrid(2:M+1,1:N) ...
            + fgrid(2:M+1,2:N+1) ...
            + fgrid(1:M,2:N+1) ...
            );
'%--------------------------------------------------------------------------
%SHEL SHallow-water numerical modEL
%Copyright (C) 2006,2009,2010. Guillaume Riflet, Instituto Superior Técnico
%da Universidade Técnica de Lisboa.
%--------------------------------------------------------------------------'
}}}

Right after creating the function, call it from the main function in the computeDiagnostic.m file, [http://code.google.com/p/shel/source/browse/trunk/ComputeDiagnostics.m#176 right before the interpolation of U and V to T-cells and the 1D variables computation]:

{{{
'%%%%Begin new code here%%%%%'
'%dummy1'
computeDummy1_w;
'%%%%End new code%%%%%%%%%%%%'

'%%interpolate from U and V to T cells'
u_t = .5 * ( u(1:M,:) + u(2:M+1,:) );
v_t = .5 * ( v(:,1:N) + v(:,2:N+1) );

Hnoland = H;
Hnoland(find(H < -1)) = 0.;

'%Volume
%volume(l) = dA * sum(sum(Hnoland)); %m3
%Perturbed volume'
volume(l) = dA * sum(sum(eta .* mask)); %m3
}}}

=Update the _property list_=
==visualize_v2 and visualize_v4 GUI==
==[http://code.google.com/p/shel/source/browse/trunk/plotmodel.m plotmodel.m]==